#!/usr/bin/python3

import os
import sys
import re
import argparse
from argparse import RawTextHelpFormatter


def get_parser():
    """
    This function parses the arguments provided by the user :return: a dictionary having a key for each arguments
    :return: a dictionary having a key for each arguments
    :rtype: dict
    """
    parser = argparse.ArgumentParser(
        description = 'This script is used to concatenate the single copy orthologue generated by OrthoFinder to the phy format for the phylogenomic an
alysis\n',
        usage = 'python3 Concatenating_Single_Copy_Orthologue.py -i <Single_Copy_Orthologue_Sequences_folder_of_OrthoFinder> -a <MultipleSequenceAlignm
ents_folder_of_OrthoFinder> -o <output.phy>',
        formatter_class = RawTextHelpFormatter, add_help = False)

    required = parser.add_argument_group('required arguments')
    optional = parser.add_argument_group('optional arguments')

    required.add_argument(
        '-i', '--in', dest = 'in', required = True, metavar = 'IN', help = 'Single_Copy_Orthologue_Sequences folder of OrthoFinder')

    required.add_argument(
        '-a', '--align', dest = 'align', required = True, metavar = 'ALIGN', help = 'MultipleSequenceAlignments folder of OrthoFinder')

    required.add_argument(
        '-o', '--out', dest = 'out', required = True, metavar = 'OUTPUT',
        help = 'Output file in phylip format. WARNING: do not provide a path')

    optional.add_argument('-h', '--help', action = "help", help = "Show this help message and exit")

    return parser.parse_args()


def concatenating(single_folder, align_folder):

	single_copy = []

	for files in os.listdir(single_folder):
		single_copy.append(files)

	seq = {}
	for files in os.listdir(align_folder):
		if files in single_copy:
			files = align_folder + '/' + files
			for line in open(files, 'r'):
				if line.startswith('>'):
					pattern1 = re.compile(r'>(\S+)_gene_\S+')
					pattern2 = re.compile(r'>(\S+)_4_1_\S+')

					if pattern1.search(line):
						sp_id = pattern1.findall(line)[0]
					elif pattern2.search(line):
						sp_id = pattern2.findall(line)[0]
				else:
					if sp_id in seq:
						seq[sp_id] += line.replace('\n', '').strip()
					else:
						seq[sp_id] = ''

	return seq


def main():
	params = vars(get_parser())

	con_seq = concatenating(params['in'], params['align'])

	#outfile = params['out']

	o = open(params['out'], 'w')

	sp_list = list(con_seq.keys())
	print(len(con_seq), len(con_seq[sp_list[0]]), file = o)
	for key, value in con_seq.items():
		print(key, "\t", value, file = o)


if __name__ == "__main__":
	main()
